\section{Monads}
With the signature of \texttt{\red{Monad} m => m a}, a monad is simply a wrapper around another type. A monad implements the following functions (only \texttt{(>>=)} is required): \texttt{bind} (\texttt{(<<=)}); \texttt{then} (\texttt{(>>)}); \texttt{return}; and \texttt{fail}.

\subsection{Bind}
\bordertext{\texttt{(>>=) :: \red{Monad} m => m a -> (a -> m b) -> m b}}
This function takes a monad and a function which takes a raw value and returns a new monad, and returns another new monad.

When implemented, then, we may vary the action taken depending on the value of the provided monad, such as returning a default value -- this is what \texttt{(>>=)} does with \texttt{Maybe}, as shown below: 

\subsubsection{Example with \texttt{Maybe}}
\bordertext{\texttt{add :: \red{Num} a => \red{Maybe} a -> \red{Maybe a} -> \red{Maybe a}}

\texttt{add mx my = mx >>= (\symbol{92}x -> my >>= (\symbol{92}y -> Just (x + y)))}}

Then addition works as expected:

\texttt{> add (Just 1) (Just 2)}

\texttt{Just 3}

But if either \texttt{mx} or \texttt{my} is \texttt{Nothing}, \texttt{(>>=)} skips the function and returns a default of \texttt{Nothing}, propagating the ``error''.

\texttt{> add Nothing (Just 2)}

\texttt{Nothing}

\subsection{Then}
\bordertext{\texttt{(>>) :: \red{Monad} m => m a -> m b -> m a}}

This function discards the second monad given to it. \texttt{m >> n} is equivalent to \texttt{m >>= \symbol{92}\_ -> n}.

``Then'' can be though of wanting to carry out an action but not caring what the result is.

\subsection{Return}
\bordertext{\texttt{return :: \red{Monad} m => a -> m a}}

Return wraps a monad around a raw value.

Using the example from the Bind section, we could substitute the explicit \texttt{Just} with the more general \texttt{return}. Now, this would theoretically work with any appropriately-defined monad.

\bordertext{\texttt{add mx my = mx >>= (\symbol{92}x -> my >>= (\symbol{92}y -> return (x + y)))}}

\subsection{Fail}
\bordertext{\texttt{fail :: \red{Monad} m => \red{String} -> m a}}

Fail is intended to be called when something goes wrong. The default implementation is to call \texttt{error} (i.e. error out of the program), but it may be implemented so that certain errors may be handled and return an appropriate monad as a response.

\subsection{``do'' Syntax}

Chaining together applications of \texttt{(>>=)}, \texttt{(>>)} and lambda functions can get tedious; that's where the syntactic sugar ``do'' expression comes in.

The ``statements'' inside of \texttt{do} are executed in order, and if one ``statement'' fails this will be propagated through.

\subsubsection{Bind}
We can substitute the ``bind'' construct
\bordertext{\texttt{m >>= (\symbol{92}x -> \ldots)}}
with
\bordertext{\texttt{\blue{do}}

\quad\texttt{x <- m}

\quad\ldots
}

\subsubsection{Then}
We can substitute the ``then'' construct
\bordertext{\texttt{m >> \ldots}}
with
\bordertext{\texttt{\blue{do}}

\quad\texttt{m}

\quad\ldots
}


\subsubsection{Example}
Translating the above \texttt{add} function into \texttt{do}-syntax:
\bordertext{
\texttt{add mx my = \blue{do}}

\quad\texttt{x <- mx}

\quad\texttt{y <- yx}

\quad\texttt{return (x + y)}
}

\subsection{Monad Laws}
Defined monads have the following properties. Any monad implemented must abide by these also.
\begin{itemize}
  \item \textbf{Left identity} -- \texttt{return a >>= k} $\equiv$ \texttt{k a} where \texttt{a} is any value, \texttt{k} is a function;
  \item \textbf{Right identity} -- \texttt{m >>= return} $\equiv$ \texttt{m} where \texttt{m} is a monad;
  \item \textbf{Associativity} -- \texttt{m >>= (\symbol{92}x -> k x >>= h)} $\equiv$ \texttt{(m >>= k) >>= h} where \texttt{m} is a monad, \texttt{k,m} are functions.
\end{itemize}