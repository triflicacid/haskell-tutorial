\section{Types}

Every expression in Haskell has a type. Types are inferred, even when given explicitly.

Types always begin with an UPPERCASE letter.

\subsection{Variable Types}

\begin{center}
  \texttt{var :: \red{type}}
\end{center}

\subsubsection{Lists}

To define a list of a \texttt{\red{type}}, one would write \texttt{[\red{type}]}. This may be nested.

\subsection{Function Types}

\begin{center}
  \texttt{func :: \red{type1} -> ... -> \red{typeN} -> \red{ret\_type}}
\end{center}

Where the function \texttt{func} takes $n$ arguments of types \texttt{\red{type1}, ..., \red{typeN}} and returns \texttt{\red{ret\_type}}.

\subsubsection{Type Variables}

Type variables may be used where any type would be permissable and must be lowercase. For example,

\begin{center}
  \texttt{id :: a -> a}

  \texttt{id x = x}
\end{center}

\subsection{Type Aliasing}
This doesn't define a new datatype, but rather an alias for another type.
\begin{center}
  \texttt{\blue{type} Pos = \red{type}}
\end{center}

A common example is using a tuple e.g. \texttt{\blue{type} Pos = (\red{Int}, \red{Int})}. The type name need not be stated in pattern matching.

\subsection{Type Classes}
Type classes may be used to restrict the types a polymorphic function may take. This is useful if we would like to use features in a polymorphic function that may only be available to certain types.

To impose a constraint on variable \texttt{a} in a function \texttt{f}: \texttt{f :: (\texttt<TypeClass> a, ...) => ...}.

\subsubsection{Definition}
A type class definition begins with

\texttt{\blue{class} <Name> <var> \blue{where}}

Below is a list of function declarations. For a type to be a member of \texttt{<Name>}, it must implement all of these functions.

\subsubsection{Implmentation}
To define a new type which belongs to a type class:
\texttt{\blue{instance} <TypeClass> <TypeName> \blue{where}}

Where below this is a list of function definitions.

\subsubsection{Common Type Classes}
Common type classes include:
\begin{itemize}
  \item \texttt{\red{Eq}} -- types which may be compared i.e. \texttt{(==)} is defined;
  \item \texttt{\red{Num}} -- numeric types, gives us access to standard mathematical operations i.e. \texttt{(+), (-), (*), abs, ...} are defined;
  \item \texttt{\red{Ord}} -- types which may be ordered, imposes a total ordering i.e. \texttt{(<), (>), (<=)} are defined;
  \item \texttt{\red{Read}} -- types which may be converted from a string i.e. \texttt{read} is defined;
  \item \texttt{\red{Show}} -- types which may be converted to a string i.e. \texttt{show} is defined;
  \item \texttt{\red{Integral}} -- types which are integer-like i.e. \texttt{div, ...} is defined;
  \item \texttt{\red{Floating}} -- types which are float-like i.e. \texttt{(/), ...} is defined;
  \item \texttt{\red{Enum}} -- types which may be enumerated i.e. \texttt{succ, pred, ...} are defined;
\end{itemize}

\subsection{Defining Datatypes}
The \blue{data} keyword is used to define a new datatype; unlike the above, these are entirely custom.

This may be done using the \texttt{data} keyword:
\begin{center}
  \texttt{\blue{data} Name = \red{Constructor1} <args> | \ldots}
\end{center}
where \texttt{<args>} are the \textit{types} of each argument, not literals.

\subsubsection{Examples}
\begin{itemize}
  \item \url{expr.hs} - A program to build and evaluate expressions;
  \item \url{tree.hs} - A representation of a tree structure;
  \item \url{nat-num.hs} - A definition of natural numbers using the successor function;
\end{itemize}