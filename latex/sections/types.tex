\section{Types}

Every expression in Haskell has a type. Types are inferred, even when given explicitly.

Types always begin with an UPPERCASE letter.

The cardinality of a type is how many \textit{states} the data type could hold. Polymorphic types have no cardinality.

\subsection{Variable Types}

\begin{center}
  \texttt{var :: \red{type}}
\end{center}

\subsubsection{Lists}

To define a list of a \texttt{\red{type}}, one would write \texttt{[\red{type}]}. This may be nested.

\subsection{Function Types}

\begin{center}
  \texttt{func :: \red{type1} -> ... -> \red{typeN} -> \red{ret\_type}}
\end{center}

Where the function \texttt{func} takes $n$ arguments of types \texttt{\red{type1}, ..., \red{typeN}} and returns \texttt{\red{ret\_type}}.

\subsubsection{Type Variables}

Type variables may be used where any type would be permissable and must be lowercase. For example,

\begin{center}
  \texttt{id :: a -> a}

  \texttt{id x = x}
\end{center}

This is called ``parametric polymorphism''.

\subsection{Type Aliasing}
This doesn't define a new datatype, but rather an alias for another type.
\begin{center}
  \texttt{\blue{type} Pos = \red{type}}
\end{center}

A common example is using a tuple e.g. \texttt{\blue{type} Pos = (\red{Int}, \red{Int})}. The type name need not be stated in pattern matching.

\subsection{Type Classes}
Type classes may be used to restrict the types a polymorphic function may take. This is useful if we would like to use features in a polymorphic function that may only be available to certain types. For a type to be a member of a type class, it must implement all of the required methods.

To impose a constraint on variable \texttt{a} in a function \texttt{f}: \texttt{f :: (\texttt<TypeClass> a, ...) => ...}. This is called ``ad-hoc polymorphism''.

\subsubsection{Definition}
A type class definition begins with

\texttt{\blue{class} <Name> <var> \blue{where}}

Below is a list of function declarations. For a type to be a member of \texttt{<Name>}, it must implement all of these functions.

\subsubsection{Implementation}
To define a new type which belongs to a type class:
\texttt{\blue{instance} <TypeClass> <TypeName> \blue{where}}

Where below this is a list of function definitions.

\subsubsection{Common Type Classes}
Common type classes include:
\begin{itemize}
  \item \texttt{\red{Eq}} -- types which may be compared i.e. \texttt{(==)} is defined;
  \item \texttt{\red{Num}} -- numeric types, gives us access to standard mathematical operations i.e. \texttt{(+), (-), (*), abs, ...} are defined;
  \item \texttt{\red{Ord}} -- types which may be ordered, imposes a total ordering i.e. \texttt{(<), (>), (<=)} are defined;
  \item \texttt{\red{Read}} -- types which may be converted from a string i.e. \texttt{read} is defined;
  \item \texttt{\red{Show}} -- types which may be converted to a string i.e. \texttt{show} is defined;
  \item \texttt{\red{Integral}} -- types which are integer-like i.e. \texttt{div, ...} is defined;
  \item \texttt{\red{Floating}} -- types which are float-like i.e. \texttt{(/), ...} is defined;
  \item \texttt{\red{Enum}} -- types which may be enumerated i.e. \texttt{succ, pred, ...} are defined;
\end{itemize}

\textit{N.B. for information on complex type classes, see Type Class section}

\subsubsection{Instances}
Intances allow us to write functions which make use of type classes. Syntax:

\texttt{\red{instance} (<constraints>) => <typeClass> <value> \red{where}} followed by a list of function definitions.

\subsubsection{Derivation}
The \texttt{\blue{deriving}} keyword can be used to automatically generate implementations for the given type class(es).

Syntax: \texttt{\blue{data} <Name> = \ldots \blue{deriving} (<Class1>, \ldots)}

Example: \texttt{\blue{data} Shape = Circle Int | Rect Int Int \blue{deriving} Show}. Then, \texttt{\blue{print} (Circle 5)} $\rightarrow$ \texttt{Circle 5}.

\subsection{Defining Datatypes}
The \blue{data} keyword is used to define a new datatype; unlike the above, these are entirely custom.

This may be done using the \texttt{data} keyword:
\begin{center}
  \texttt{\blue{data} Name = \red{Constructor1} [<args>] | \ldots}
\end{center}
where \texttt{<args>} are the \textit{types} of each argument, not literals.

Constructors are either plain values, or functions which take \texttt{args} and return the datatype.

Data consturctors can include polymorphism by including type variables after \texttt{<Name>} e.g. \texttt{\blue{data} Maybe a = Nothing | Just a}.

\subsubsection{Examples}
\begin{itemize}
  \item \url{rock-paper-scissors.hs} -- A basic example revolving around Rock-Paper-Scissors;
  \item \url{expr.hs} -- A program to build and evaluate expressions;
  \item \url{tree.hs} -- A representation of a tree structure;
  \item \url{nat-num.hs} -- A definition of natural numbers using the successor function;
\end{itemize}

\subsection{Records}
Records allow data to be stored with an associated name.

Syntax:
\begin{center}
  \texttt{\blue{data} <Name> = <Name> \{ <field> :: <type>, \ldots \}}
\end{center}
This will automatically generate functions \texttt{<field> :: <Name> -> <type>} to extract said properties. This has the side-effect that field names must be globally unique.

\subsubsection{Multiple Constructors}
Note that records may also have mutliple constructors,

\texttt{\blue{data} Point = D2 \{ x :: \red{Int}, y :: \red{Int} \} | D3 \{ x :: \red{Int}, y :: \red{Int}, z :: \red{Int} \}}

Duplicate field names in this context is OK.

This will generate functions \texttt{x}, \texttt{y} and \texttt{z} all with the signature \texttt{x/y/z :: Point -> \red{Int}}. Both \texttt{x} and \texttt{y} will work on either \texttt{D2} or \texttt{D3}, but applying \texttt{z} to \texttt{D2} will throw an exception.

For an example, see \url{code/vector.hs}.